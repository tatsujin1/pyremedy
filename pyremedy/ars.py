from collections import OrderedDict
from ctypes import (
    CDLL, sizeof, cast, byref, memset, c_char_p, c_int, c_uint, c_size_t,
    c_void_p, POINTER
)
from datetime import datetime

from . import arh
from .exceptions import ARSError

import sys
if sys.version_info[0] >= 3:
	bytestr_type = bytes
	unicodestr_type = str
else:
	bytestr_type = str
	unicodestr_type = unicode
	
	
def enc_u8(us):
    if type(us) is unicodestr_type:
        return us.encode('utf-8')
    return us  # assume it is already correct encoding (or another type)
	
def dec_u8(bs):
    if type(bs) is bytestr_type:
        return bs.decode('utf-8')
    return bs  # assume it is already unicode (or a disparate type)



class ARS(object):
    """The ARS object implements a simple CRUD interface for Remedy ARS
    servers.  It is passed server details and credentials and acts as the main
    object which talks to Remedy ARS.

    The ARS object also provides a caching mechanism for schema lists and
    field mappings.

    :param str server: the Remedy ARS server to connect to
    :param str user: the username to authenticate with
    :param str password: the password to authenticate with
    :param int port: the port number of the server
    :param int rpc_program_number: the RPC program number of the server
    :raises: ARSError
    """

    def __init__(self, server, user, password, port=0, rpc_program_number=0):
        #: The Remedy ARS C API shared object file which is used to interact
        #: with the Remedy server
        self.arlib = CDLL('libar_lx64.so')

        #: The standard C library used to run several lower-lever C functions
        self.clib = CDLL('libc.so.6')

        #: The control record for each operation containing details about the
        #: user and session performing each operation
        self.control = arh.ARControlStruct()

        #: A list of warnings or errors generated from each call to Remedy ARS
        self.status = arh.ARStatusList()

        #: A list of tuples containing errors that occurred on the last call
        self.errors = []

        #: A cache containing all schemas
        self.schema_cache = None

        #: A cache containing field id to name mappings for schemas
        self.field_id_to_name_cache = {}

        #: A cache containing field name to id mappings for schemas
        self.field_name_to_id_cache = {}

        #: A cache containing field id to type mappings for schemas
        self.field_id_to_type_cache = {}

        #: A cache containing enum id to name mappings for a particular field
        self.enum_id_to_name_cache = {}

        #: A cache containing enum name to id mappings for a particular field
        self.enum_name_to_id_cache = {}

        # Explicitly define argument and return types for C functions
        self._register_clib_functions()

        # Explicitly define argument and return types for Remedy functions
        self._register_arlib_functions()

        # Initialise control to 0 for safety
        memset(byref(self.control), 0, sizeof(arh.ARControlStruct))

        # Load the ARControlStruct with server details and user credentials
        self.control.server = enc_u8(server)
        self.control.user = enc_u8(user)
        self.control.password = enc_u8(password)

        # Note on FreeAR functions:
        #
        # FreeAR functions are used to clear the contents of memory for
        # particular struct types.  These functions are used when a Remedy ARS
        # operation fills a struct as a return value.
        #
        # The second argument in the FreeAR functions is a boolean
        # known as freeStruct which specifies whether the memory should be
        # deallocated along with the contents.

        # Performs server initalisation
        if (
            self.arlib.ARInitialization(
                # ARControlStruct *control: the control record
                byref(self.control),

                # (return) ARStatusList *status: notes, warnings or errors
                # generated by the operation
                byref(self.status)
            ) >= arh.AR_RETURN_ERROR
        ):
            self._update_errors()
            self.arlib.FreeARStatusList(byref(self.status), arh.FALSE)
            raise ARSError(
                'Enable to perform initialisation against server '
                '{}'.format(server)
            )

        self.arlib.FreeARStatusList(byref(self.status), arh.FALSE)

        server_artype = arh.ARNameType()
        server_artype.value = self.control.server

        # Set the server port and/or RPC program number (if specified)
        if port or rpc_program_number:
            if (
                self.arlib.ARSetServerPort(
                    # ARControlStruct *control: the control record
                    byref(self.control),
                    # ARNameType server: the server to update with the port
                    server_artype,
                    # int port: the port number
                    port,
                    # int rpcProgramNum: the RPC program of the server
                    rpc_program_number,

                    # (return) ARStatusList *status: notes, warnings or errors
                    # generated by the operation
                    byref(self.status)
                ) >= arh.AR_RETURN_ERROR
            ):
                self._update_errors()
                self.arlib.FreeARStatusList(byref(self.status), arh.FALSE)
                raise ARSError(
                    'Unable to set the port to {} and RPC program number to '
                    '{} for server {}'.format(port, rpc_program_number, server)
                )

            self.arlib.FreeARStatusList(byref(self.status), arh.FALSE)

    def terminate(self):
        """Perform a cleanup and disconnect the session

        :raises: ARSError
        """

        # Clear previous errors
        self.errors = []

        if (
            self.arlib.ARTermination(
                # ARControlStruct *control: the control record
                byref(self.control),

                # (return) ARStatusList *status: notes, warnings or errors
                # generated by the operation
                byref(self.status)
            ) >= arh.AR_RETURN_ERROR
        ):
            self._update_errors()
            self.arlib.FreeARStatusList(byref(self.status), arh.FALSE)
            raise ARSError('Unable to terminate the server connection')

        self.arlib.FreeARStatusList(byref(self.status), arh.FALSE)

    def schemas(self):
        """Retrieves a list of all available schemas on the specified Remedy
        ARS server

        :return: a list of schema names
        :raises: ARSError
        """

        # Clear previous errors
        self.errors = []

        # Use the cache if possible
        if self.schema_cache is not None:
            return self.schema_cache

        name_artype = arh.ARNameType()
        name_artype.value = b''
        schema_list = arh.ARNameList()

        if (
            self.arlib.ARGetListSchema(
                # ARControlStruct *control: the control record
                byref(self.control),
                # ARTimestamp changedSince: retrieves forms with a chosen
                # modification timestamp
                0,
                # unsigned int schemaType: get all schemas
                arh.AR_LIST_SCHEMA_ALL | arh.AR_HIDDEN_INCREMENT,
                # ARNameType name: specify which form this depends on (ignored
                # with our schemaType)
                name_artype,
                # ARInternalIdList *fieldIdList: filter the schemas by a given
                # set of fields
                None,
                # ARPropList *objPropList: search for specify object properties
                None,

                # (return) ARNameList *nameList: the list of schemas
                byref(schema_list),
                # (return) ARStatusList *status: notes, warnings or errors
                # generated by the operation
                byref(self.status)
            ) >= arh.AR_RETURN_ERROR
        ):
            self._update_errors()
            self.arlib.FreeARNameList(byref(schema_list), arh.FALSE)
            self.arlib.FreeARStatusList(byref(self.status), arh.FALSE)
            raise ARSError('Unable to obtain a list of schemas')

        # Save the schema list into the cache
        self.schema_cache = [
            dec_u8(schema_list.nameList[i].value) for i in range(schema_list.numItems)
        ]

        self.arlib.FreeARNameList(byref(schema_list), arh.FALSE)
        self.arlib.FreeARStatusList(byref(self.status), arh.FALSE)

        return self.schema_cache

    def fields(self, schema):
        """Returns a list of field names provided by a selected schema

        :param str schema: the schema name to retrieve field names for
        :raises: ARSError
        """

        # Ensure we have all field and enum details for the schema
        self.update_fields(schema)

        # Return just the field names of the selected schema
        return self.field_name_to_id_cache[schema].keys()

    def get(self, schema, entry_id, fields):
        """Retrieves a particular entry in the requested schema using the
        given entry id.

        :param str schema: the schema name to retrieve the entry for
        :param str entry_id: the entry id of the entry that you wish to
                             retrieve
        :param fields: a list of field names to retrieve from the schema
        :type fields: list of strings
        :return: a dict containing the field names and values requested for
                 the respective entry id
        :raises: ARSError
        """

        # Ensure we have all field and enum details for the schema
        self.update_fields(schema)

        # Validate that all fields exist.  Note that this is performed here
        # so that we aren't in the middle of allocating memory to the
        # AREntryListFieldList struct when we realise a field is invalid.
        missing = set(self.field_name_to_id_cache[schema]).difference(fields)
        if missing:
            raise ARSError(
				'Schema {} does not have field(s): {}'.format(schema, ', '.join(sorted(missing)))
			)

        entry_id_list = arh.AREntryIdList()
        entry_id_list.numItems = 1
        entry_id_list.entryIdList = cast(
            self.clib.malloc(
                entry_id_list.numItems * sizeof(arh.AREntryIdType)
            ), POINTER(arh.AREntryIdType)
        )
        entry_id_list.entryIdList[0].value = enc_u8(entry_id)

        internal_id_list = arh.ARInternalIdList()
        internal_id_list.numItems = len(fields)
        internal_id_list.internalIdList = cast(
            self.clib.malloc(
                internal_id_list.numItems * sizeof(arh.ARInternalId)
            ), POINTER(arh.ARInternalId)
        )

        for i, field in enumerate(fields):
            internal_id_list.internalIdList[i] = (
                self.field_name_to_id_cache[schema][field]
            )

        schema_artype = arh.ARNameType()
        schema_artype.value = enc_u8(schema)
        field_value_list = arh.ARFieldValueList()

        if (
            self.arlib.ARGetEntry(
                # ARControlStruct *control: the control record
                byref(self.control),
                # ARNameType schema: the schema to retrieve the entry for
                schema_artype,
                # AREntryIdList *entryId: the entry id to retrieve
                byref(entry_id_list),
                # ARInternalIdList *idList: the field ids to retrieve
                byref(internal_id_list),

                # (return) ARFieldValueList *fieldList: a list of key/value
                # pairs that provide the data for the retrieved entry.
                byref(field_value_list),
                # (return) ARStatusList *status: notes, warnings or errors
                # generated by the operation
                byref(self.status)
            ) >= arh.AR_RETURN_ERROR
        ):
            self.arlib.FreeAREntryIdList(byref(entry_id_list), arh.FALSE)
            self.arlib.FreeARInternalIdList(byref(internal_id_list), arh.FALSE)
            self.arlib.FreeARFieldValueList(byref(field_value_list), arh.FALSE)
            self.arlib.FreeARStatusList(byref(self.status), arh.FALSE)
            raise ARSError(
                'Unable to retrieve the entry with id {} from schema '
                '{}'.format(entry_id, schema)
            )

        # Create an empty dict for the values
        entry_values = {}

        for i in range(field_value_list.numItems):
            field_id = field_value_list.fieldValueList[i].fieldId
            field_name = dec_u8(self.field_id_to_name_cache[schema][field_id])
            value_struct = field_value_list.fieldValueList[i].value
            try:
                entry_values[field_name] = dec_u8(self._extract_field(
                    schema, field_id, value_struct
                ))
            except ARSError:
                self.arlib.FreeAREntryIdList(byref(entry_id_list), arh.FALSE)
                self.arlib.FreeARInternalIdList(
                    byref(internal_id_list), arh.FALSE
                )
                self.arlib.FreeARFieldValueList(
                    byref(field_value_list), arh.FALSE
                )
                self.arlib.FreeARStatusList(byref(self.status), arh.FALSE)
                raise

        self.arlib.FreeAREntryIdList(byref(entry_id_list), arh.FALSE)
        self.arlib.FreeARInternalIdList(byref(internal_id_list), arh.FALSE)
        self.arlib.FreeARFieldValueList(byref(field_value_list), arh.FALSE)
        self.arlib.FreeARStatusList(byref(self.status), arh.FALSE)

        return entry_values

    def query(
        self, schema, qualifier, fields, offset=arh.AR_START_WITH_FIRST_ENTRY,
        limit=arh.AR_NO_MAX_LIST_RETRIEVE
    ):
        """Runs a specified qualification string against a chosen schema and
        returns the all related records with the fields specified by the
        caller.

        :param str schema: the schema name to run the query against
        :param str qualifier: the query determining which records to retrieve
        :param fields: a list of field names to retrieve from the schema
        :type fields: list of strings
        :param int offset: the index of the first record to retrieve
        :param int limit: limit the number of returned results to a given
                          number
        :return: a list of tuples containing the entries matching the criteria
                 specified whereby each tuple contains the entry id and
                 entry values
        :raises: ARSError
        """

        # Ensure we have all field and enum details for the schema
        self.update_fields(schema)

        # Validate that all fields exist.  Note that this is performed here
        # so that we aren't in the middle of allocating memory to the
        # AREntryListFieldList struct when we realise a field is invalid.
        missing = set(self.field_name_to_id_cache[schema]).difference(fields)
        if missing:
            raise ARSError(
				'Schema {} does not have field(s): {}'.format(schema, ', '.join(sorted(missing)))
			)

        schema_artype = arh.ARNameType()
        schema_artype.value = schema
        display_tag_artype = arh.ARNameType()
        display_tag_artype.value = ''
        qualifier_struct = arh.ARQualifierStruct()

        if (
            self.arlib.ARLoadARQualifierStruct(
                # ARControlStruct *control: the control record
                byref(self.control),
                # ARNameType schema: the schema to build the qualifier for
                schema_artype,
                # ARNameType displayTag: the name of the form view to use for
                # resolving field names
                display_tag_artype,
                # char *qualString: the qualification string (query) to search
                # with
                qualifier,

                # (return) ARQualifierStruct *qualifier: the newly built
                # ARQualifierStruct
                byref(qualifier_struct),
                # (return) ARStatusList *status: notes, warnings or errors
                # generated by the operation
                byref(self.status)
            ) >= arh.AR_RETURN_ERROR
        ):
            self._update_errors()
            self.arlib.FreeARQualifierStruct(
                byref(qualifier_struct), arh.FALSE
            )
            self.arlib.FreeARStatusList(byref(self.status), arh.FALSE)
            raise ARSError(
                'Unable to load the qualifier using the provided '
                'qualification string for schema {}'.format(schema)
            )

        # Note that we don't run FreeARQualifierStruct here as we need the
        # qualifier for the next call
        self.arlib.FreeARStatusList(byref(self.status), arh.FALSE)

        field_list = arh.AREntryListFieldList()
        field_list.numItems = len(fields)
        field_list.fieldsList = cast(
            self.clib.malloc(
                field_list.numItems * sizeof(arh.AREntryListFieldStruct)
            ), POINTER(arh.AREntryListFieldStruct)
        )

        for i, field in enumerate(fields):
            field_list.fieldsList[i].fieldId = (
                self.field_name_to_id_cache[schema][field]
            )
            # From the C API Reference document (Chapter 3 / Entries)
            # For ARGetListEntryWithFields, set this value to a number greater
            # than 0.
            field_list.fieldsList[i].columnWidth = 1
            # From the C API Reference document (Chapter 3 / Entries)
            # For ARGetListEntryWithFields, set this value to one blank space.
            field_list.fieldsList[i].separator = b' '

        schema_artype = arh.ARNameType()
        schema_artype.value = schema
        num_matches = c_uint()
        entry_list = arh.AREntryListFieldValueList()

        if (
            self.arlib.ARGetListEntryWithFields(
                # ARControlStruct *control: the control record
                byref(self.control),
                # ARNameType schema: the schema to get entries for
                schema_artype,
                # ARQualifierStruct *qualifier: a query specifying entries to
                # retrieve
                byref(qualifier_struct),
                # AREntryListFieldList *getListFields: a list of fields to
                # retrieve with each entry
                byref(field_list),
                # ARSortList *sortList: list of fields to sort results by
                # (NULL for default sort)
                None,
                # unsigned int firstRetrieve: the first record to retrieve
                offset,
                # unsigned int maxRetrieve: the maximum number of items to
                # retrieve
                limit,
                # ARBoolean useLocale: whether to search based on locale
                arh.FALSE,

                # (return) AREntryListFieldValueList *entryList: the entries
                # retrieved
                byref(entry_list),
                # (return) unsigned int numMatches: the number of entries
                # retrieved
                byref(num_matches),
                # (return) ARStatusList *status: notes, warnings or errors
                # generated by the operation
                byref(self.status)
            ) >= arh.AR_RETURN_ERROR
        ):
            self._update_errors()
            self.arlib.FreeARQualifierStruct(
                byref(qualifier_struct), arh.FALSE
            )
            self.arlib.FreeAREntryListFieldList(byref(field_list), arh.FALSE)
            self.arlib.FreeAREntryListFieldValueList(
                byref(entry_list), arh.FALSE
            )
            self.arlib.FreeARStatusList(byref(self.status), arh.FALSE)
            raise ARSError(
                'Unable to obtain a list of entries using the provided '
                'qualification string for schema {}'.format(schema)
            )

        entries = []

        for i in range(entry_list.numItems):
            # Entries containing more than one id are not supported
            # (ids are supposed to be unique aren't they?)
            if entry_list.entryList[i].entryId.numItems != 1:
                self.arlib.FreeARQualifierStruct(
                    byref(qualifier_struct), arh.FALSE
                )
                self.arlib.FreeAREntryListFieldList(
                    byref(field_list), arh.FALSE
                )
                self.arlib.FreeAREntryListFieldValueList(
                    byref(entry_list), arh.FALSE
                )
                self.arlib.FreeARStatusList(byref(self.status), arh.FALSE)
                raise ARSError(
                    'One or more entries contained multiple IDs that are not '
                    'supported by PyRemedy'
                )

            # Extract the entry id and create an empty dict for the values
            entry_id = entry_list.entryList[i].entryId.entryIdList[0].value
            entry_values = {}

            # Grab the values list for the entry
            field_value_list = entry_list.entryList[i].entryValues.contents

            for j in range(field_value_list.numItems):
                field_id = field_value_list.fieldValueList[j].fieldId
                field_name = self.field_id_to_name_cache[schema][field_id]
                value_struct = field_value_list.fieldValueList[j].value

                # Extract the appropriate piece of data depending on its type
                try:
                    entry_values[field_name] = self._extract_field(
                        schema, field_id, value_struct
                    )
                except ARSError:
                    self.arlib.FreeARQualifierStruct(
                        byref(qualifier_struct), arh.FALSE
                    )
                    self.arlib.FreeAREntryListFieldList(
                        byref(field_list), arh.FALSE
                    )
                    self.arlib.FreeAREntryListFieldValueList(
                        byref(entry_list), arh.FALSE
                    )
                    self.arlib.FreeARStatusList(byref(self.status), arh.FALSE)
                    raise

            entries.append((entry_id, entry_values))

        self.arlib.FreeARQualifierStruct(byref(qualifier_struct), arh.FALSE)
        self.arlib.FreeAREntryListFieldList(byref(field_list), arh.FALSE)
        self.arlib.FreeAREntryListFieldValueList(byref(entry_list), arh.FALSE)
        self.arlib.FreeARStatusList(byref(self.status), arh.FALSE)

        return entries

    def create(self, schema, entry_values):
        """Creates a new entry in a given schema using the provided entry
        values.

        :param str schema: the schema where the entry is to be created
        :param entry_values: a dict containing the field names and values
                             for the new entry
        :type entry_values: dict of string to values corresponding to the type
                            of the respective field
        :return: the entry id of the newly created entry
        :raises: ARSError
        """

        # Ensure we have all field and enum details for the schema
        self.update_fields(schema)

        # Validate that all fields exist.  Note that this is performed here
        # so that we aren't in the middle of allocating memory to the
        # ARFieldValueList struct when we realise a field is invalid.
        missing = set(self.field_name_to_id_cache[schema]).difference(entry_values.keys())
        if missing:
            raise ARSError(
				'Schema {} does not have field(s): {}'.format(schema, ', '.join(sorted(missing)))
			)

        # Prepare the fields that will be added to the new entry
        field_value_list = arh.ARFieldValueList()
        field_value_list.numItems = len(entry_values)
        field_value_list.fieldValueList = cast(
            self.clib.calloc(
                field_value_list.numItems, sizeof(arh.ARFieldValueStruct)
            ), POINTER(arh.ARFieldValueStruct)
        )

        for i, (field_name, value) in enumerate(entry_values.items()):
            field_id = self.field_name_to_id_cache[schema][field_name]
            self._update_field(
                schema, field_id, value, field_value_list.fieldValueList[i]
            )

        entry_id_artype = arh.AREntryIdType()
        schema_artype = arh.ARNameType()
        schema_artype.value = enc_u8(schema)

        if (
            self.arlib.ARCreateEntry(
                # ARControlStruct *control: the control record
                byref(self.control),
                # ARNameType schema: the name of the schema to create the
                # entry in
                schema_artype,
                # ARFieldValueList *fieldList: a list of key/value pairs which
                # identify the data for the new entry
                byref(field_value_list),

                # (return) AREntryIdType entryId: the entry id of the newly
                # created entry
                entry_id_artype,
                # (return) ARStatusList *status: notes, warnings or errors
                # generated by the operation
                byref(self.status)
            ) >= arh.AR_RETURN_ERROR
        ):
            self._update_errors(schema)
            self.arlib.FreeARFieldValueList(
                byref(field_value_list), arh.FALSE
            )
            self.arlib.FreeARStatusList(byref(self.status), arh.FALSE)
            raise ARSError(
                'Unable to create a new entry for schema {}'.format(schema)
            )

        self.arlib.FreeARFieldValueList(byref(field_value_list), arh.FALSE)
        self.arlib.FreeARStatusList(byref(self.status), arh.FALSE)

        # Return the newly created entry id to the caller
        return dec_u8(entry_id_artype.value)

    def update(self, schema, entry_id, entry_values):
        """Updates a chosen entry in a given schema using the provided
        entry values.

        :param str schema: the schema where the entry is located
        :param str entry_id: the entry id of the record to be updated
        :param entry_values: a dict containing the field names and values
                             to be updated
        :type entry_values: dict of string to values corresponding to the type
                            of the respective field
        :raises: ARSError
        """

        # Ensure we have all field and enum details for the schema
        self.update_fields(schema)

        # Validate that all fields exist.  Note that this is performed here
        # so that we aren't in the middle of allocating memory to the
        # ARFieldValueList struct when we realise a field is invalid.
        missing = set(self.field_name_to_id_cache[schema]).difference(entry_values.keys())
        if missing:
            raise ARSError(
				'Schema {} does not have field(s): {}'.format(schema, ', '.join(sorted(missing)))
			)

        # Prepare the entry id struct
        entry_id_list = arh.AREntryIdList()
        entry_id_list.numItems = 1
        entry_id_list.entryIdList = cast(
            self.clib.malloc(
                entry_id_list.numItems * sizeof(arh.AREntryIdType)
            ), POINTER(arh.AREntryIdType)
        )
        entry_id_list.entryIdList[0].value = enc_u8(entry_id)

        # Prepare the fields that will be updated
        field_value_list = arh.ARFieldValueList()
        field_value_list.numItems = len(entry_values)
        field_value_list.fieldValueList = cast(
            self.clib.calloc(
                field_value_list.numItems, sizeof(arh.ARFieldValueStruct)
            ), POINTER(arh.ARFieldValueStruct)
        )

        for i, (field_name, value) in enumerate(entry_values.items()):
            field_id = self.field_name_to_id_cache[schema][field_name]
            self._update_field(
                schema, field_id, value, field_value_list.fieldValueList[i]
            )

        schema_artype = arh.ARNameType()
        schema_artype.value = enc_u8(schema)

        if (
            self.arlib.ARSetEntry(
                # ARControlStruct *control: the control record
                byref(self.control),
                # ARNameType schema: the name of the schema containing the
                # entry to be updated
                schema_artype,
                # AREntryIdList *entryId: the id of the entry to update
                byref(entry_id_list),
                # ARFieldValueList *fieldList: a list of key/value pairs to
                # update
                byref(field_value_list),
                # ARTimestamp getTime: the timestamp specifying when the entry
                # was last retrieved for validation against the modified date
                # (to bypass this comparison, pass 0)
                0,
                # unsigned int option: whether to update fields in a join
                # qualification (only applies to join forms)
                arh.AR_JOIN_SETOPTION_REF,

                # (return) ARStatusList *status: notes, warnings or errors
                # generated by the operation
                byref(self.status)
            ) >= arh.AR_RETURN_ERROR
        ):
            self._update_errors(schema)
            self.arlib.FreeAREntryIdList(byref(entry_id_list), arh.FALSE)
            self.arlib.FreeARFieldValueList(byref(field_value_list), arh.FALSE)
            self.arlib.FreeARStatusList(byref(self.status), arh.FALSE)
            raise ARSError(
                'Unable to modify entry id {} for schema {}'.format(
                    entry_id, schema
                )
            )

        self.arlib.FreeAREntryIdList(byref(entry_id_list), arh.FALSE)
        self.arlib.FreeARFieldValueList(byref(field_value_list), arh.FALSE)
        self.arlib.FreeARStatusList(byref(self.status), arh.FALSE)

    def delete(self, schema, entry_id):
        """Deletes a particular entry in the requested schema using the
        given entry id.

        :param str schema: the schema name to delete the entry from
        :param str entry_id: the entry id of the entry that you wish to delete
        :raises: ARSError
        """

        # Clear previous errors
        self.errors = []

        schema_artype = arh.ARNameType()
        schema_artype.value = enc_u8(schema)

        entry_id_list = arh.AREntryIdList()
        entry_id_list.numItems = 1
        entry_id_list.entryIdList = cast(
            self.clib.malloc(
                entry_id_list.numItems * sizeof(arh.AREntryIdType)
            ), POINTER(arh.AREntryIdType)
        )
        entry_id_list.entryIdList[0].value = enc_u8(entry_id)

        if (
            self.arlib.ARDeleteEntry(
                # ARControlStruct *control: the control record
                byref(self.control),
                # ARNameType schema: the name of the schema containing the
                # entry to be deleted
                schema_artype,
                # AREntryIdList *entryId: the entry to delete
                byref(entry_id_list),
                # unsigned int option: the policy used when deleting the entry
                arh.AR_JOIN_DELOPTION_NONE,

                # (return) ARStatusList *status: notes, warnings or errors
                # generated by the operation
                byref(self.status)
            ) >= arh.AR_RETURN_ERROR
        ):
            self._update_errors()
            self.arlib.FreeAREntryIdList(byref(entry_id_list), arh.FALSE)
            self.arlib.FreeARStatusList(byref(self.status), arh.FALSE)
            raise ARSError(
                'Unable to delete entry id {} for schema {}'.format(
                    entry_id, schema
                )
            )

        self.arlib.FreeAREntryIdList(byref(entry_id_list), arh.FALSE)
        self.arlib.FreeARStatusList(byref(self.status), arh.FALSE)

    def update_fields(self, schema):
        """Determines the field IDs for all data fields on a chosen schema and
        then retrieves the related field names and enum mappings.  This method
        assumes that all field names are unique.

        :param str schema: the schema name to retrieve field information for
        :raises: ARSError
        """

        # Clear previous errors
        self.errors = []

        # Use the cache if possible
        if (
            schema in self.field_id_to_name_cache and
            schema in self.field_name_to_id_cache and
            schema in self.field_id_to_type_cache and
            schema in self.enum_id_to_name_cache and
            schema in self.enum_name_to_id_cache
        ):
            return

        schema_artype = arh.ARNameType()
        schema_artype.value = enc_u8(schema)

        field_id_list = arh.ARInternalIdList()

        if (
            self.arlib.ARGetListField(
                # ARControlStruct *control: the control record
                byref(self.control),
                # ARNameType schema: the schema to get field ids for
                schema_artype,
                # unsigned long fieldType: bitmask indicating what field types
                # we want
                arh.AR_FIELD_TYPE_DATA,
                # ARTimestamp changedSince: retrieves fields with any
                # modification timestamp
                0,
                # ARPropList objPropList: object properties to search for
                None,

                # (return) ARInternalIdList *idList: the retrieved id list
                byref(field_id_list),
                # (return) ARStatusList *status: notes, warnings or errors
                # generated by the operation
                byref(self.status)
            ) >= arh.AR_RETURN_ERROR
        ):
            self._update_errors()
            self.arlib.FreeARInternalIdList(byref(field_id_list), arh.FALSE)
            self.arlib.FreeARStatusList(byref(self.status), arh.FALSE)
            raise ARSError(
                'Unable to obtain field ids for schema {}'.format(schema)
            )

        # Note that we don't run FreeARInternalIdList here as we need the
        # field_id_list for the next call
        self.arlib.FreeARStatusList(byref(self.status), arh.FALSE)

        field_name_list = arh.ARNameList()
        field_exist_list = arh.ARBooleanList()
        field_limits_list = arh.ARFieldLimitList()
        field_type_list = arh.ARUnsignedIntList()

        if (
            self.arlib.ARGetMultipleFields(
                # ARControlStruct *control: the control record
                byref(self.control),
                # ARNameType schema: the scehma to get fields for
                schema_artype,
                # ARInternalIdList *fieldId: the field ids to retrieve
                byref(field_id_list),

                # (return) ARBooleanList *existList: whether the fields exist
                # or not
                byref(field_exist_list),
                # (return) ARInternalIdList *fieldId2: the internal ids
                # retrieved
                None,
                # (return) ARNameList *fieldName: the field names
                byref(field_name_list),
                # (return) ARFieldMappingList *fieldMap: a mapping to the
                # underlying form which to retrieve fields
                None,
                # (return) ARUnsignedIntList *dataType: field data types
                byref(field_type_list),
                # (return) ARUnsignedIntList *option: flags indicating whether
                # users must enter values in the form
                None,
                # (return) ARUnsignedIntList *createMode: flags that specify
                # the permission of fields
                None,
                # (return) ARUnsignedIntList *fieldOption: a list of bitmasks
                # indicating whether the field is to be audited or copied when
                # other fields are audited
                None,
                # (return) ARValueList *defaultVal: default field values
                None,
                # (return) ARPermissionListList *assignedGroupListList: groups
                # that have direct permission to fields
                None,
                # (return) ARPermissionListList *permissions: groups that can
                # access the fields
                None,
                # (return) ARFieldLimitList *limit: value limits fo fields
                byref(field_limits_list),
                # (return) ARDisplayInstanceListList *dInstanceList: display
                # properties
                None,
                # (return) ARTextStringList *helpText: help text
                None,
                # (return) ARTimestampList *timestamp: last modified timestamps
                None,
                # (return) ARAccessNameList *owner: the owner of fields
                None,
                # (return) ARAccessNameList *lastChanged: the user that made
                # the last change to the fields
                None,
                # (return) ARTextStringList *changeDiary: a list of change
                # entries
                None,
                # (return) ARPropListList *objPropListList: server properties
                # for fields
                None,
                # (return) ARStatusList *status: notes, warnings or errors
                # generated by the operation
                byref(self.status)
            ) >= arh.AR_RETURN_ERROR
        ):
            self._update_errors()
            self.arlib.FreeARInternalIdList(byref(field_id_list), arh.FALSE)
            self.arlib.FreeARBooleanList(byref(field_exist_list), arh.FALSE)
            self.arlib.FreeARNameList(byref(field_name_list), arh.FALSE)
            self.arlib.FreeARStatusList(byref(self.status), arh.FALSE)
            raise ARSError(
                'Unable to obtain field information for schema '
                '{}'.format(schema_u)
            )

        # Initialise the name and enum caches for this schema
        schema_u = dec_u8(schema)
        self.field_id_to_name_cache[schema_u] = OrderedDict()
        self.field_name_to_id_cache[schema_u] = OrderedDict()
        self.field_id_to_type_cache[schema_u] = OrderedDict()
        self.enum_id_to_name_cache[schema_u] = OrderedDict()
        self.enum_name_to_id_cache[schema_u] = OrderedDict()

        for i in range(field_id_list.numItems):
            # Save the field name to id mapping in the cache
            field_id = field_id_list.internalIdList[i]
            field_name = dec_u8(field_name_list.nameList[i].value)
            data_type = field_type_list.intList[i]

            # Save the field id to name mapping in the cache
            self.field_id_to_name_cache[schema_u][field_id] = field_name

            # Save the field name to id mapping in the cache
            self.field_name_to_id_cache[schema_u][field_name] = field_id

            # Save the field id to type mapping in the cache
            self.field_id_to_type_cache[schema_u][field_id] = data_type

            # Retrieve enum values if this field is an enum type
            if data_type == arh.AR_DATA_TYPE_ENUM:
                # Initialise the enum entries for this field
                self.enum_id_to_name_cache[schema_u][field_id] = {}
                self.enum_name_to_id_cache[schema_u][field_id] = {}

                field_enum_limits_list = (
                    field_limits_list.fieldLimitList[i].u.enumLimits
                )
                field_style = field_enum_limits_list.listStyle

                # Process regular enums mappings
                if field_style == arh.AR_ENUM_STYLE_REGULAR:
                    regular_list = field_enum_limits_list.u.regularList
                    for j in range(regular_list.numItems):
                        enum_id = j
                        enum_value = regular_list.nameList[j].value
                        self.enum_id_to_name_cache[schema_u][field_id][enum_id] = (
                            enum_value
                        )
                        self.enum_name_to_id_cache[schema_u][field_id][enum_value] = (
                            enum_id
                        )

                # Process custom enums mappings
                elif field_style == arh.AR_ENUM_STYLE_CUSTOM:
                    custom_list = field_enum_limits_list.u.customList
                    for j in range(custom_list.numItems):
                        enum_id = custom_list.enumItemList[j].itemNumber
                        enum_value = custom_list.enumItemList[j].itemName
                        self.enum_id_to_name_cache[schema_u][field_id][enum_id] = (
                            enum_value
                        )
                        self.enum_name_to_id_cache[schema_u][field_id][enum_value] = (
                            enum_id
                        )

                # Process query enums mappings
                else:
                    self.arlib.FreeARInternalIdList(
                        byref(field_id_list), arh.FALSE
                    )
                    self.arlib.FreeARBooleanList(
                        byref(field_exist_list), arh.FALSE
                    )
                    self.arlib.FreeARNameList(
                        byref(field_name_list), arh.FALSE
                    )
                    self.arlib.FreeARStatusList(byref(self.status), arh.FALSE)
                    raise ARSError(
                        'The field id {} for schema {} is a query enum which '
                        'is not supported by PyRemedy'.format(field_id, schema_u)
                    )

        self.arlib.FreeARInternalIdList(byref(field_id_list), arh.FALSE)
        self.arlib.FreeARBooleanList(byref(field_exist_list), arh.FALSE)
        self.arlib.FreeARNameList(byref(field_name_list), arh.FALSE)
        self.arlib.FreeARStatusList(byref(self.status), arh.FALSE)

    def _register_clib_functions(self):
        """Explicitly define argument and return types for C functions"""
        # strdup (string.h)
        self.clib.strdup.argtypes = [c_char_p]
        # Please note that the return value of strdup is actually char * but
        # we can't use this or Python will convert the result into a Python
        # string which isn't what we want.  Instead, we return a void * (or
        # alternatively we could have returned POINTER(c_char)) and cast that
        # result to a c_char_p.
        self.clib.strdup.restype = c_void_p

        # calloc (stdlib.h)
        self.clib.calloc.argtypes = [c_size_t, c_size_t]
        self.clib.calloc.restype = c_void_p

        # malloc (stdlib.h)
        self.clib.malloc.argtypes = [c_size_t]
        self.clib.malloc.restype = c_void_p

    def _register_arlib_functions(self):
        """Explicitly define argument and return types for Remedy functions."""
        # ARCreateEntry
        self.arlib.ARCreateEntry.argtypes = [
            POINTER(arh.ARControlStruct), arh.ARNameType,
            POINTER(arh.ARFieldValueList), arh.AREntryIdType,
            POINTER(arh.ARStatusList)
        ]
        self.arlib.ARCreateEntry.restype = c_int

        # ARDeleteEntry
        self.arlib.ARDeleteEntry.argtypes = [
            POINTER(arh.ARControlStruct), arh.ARNameType,
            POINTER(arh.AREntryIdList), c_uint, POINTER(arh.ARStatusList)
        ]
        self.arlib.ARDeleteEntry.restype = c_int

        # ARGetEntry
        self.arlib.ARGetEntry.argtypes = [
            POINTER(arh.ARControlStruct), arh.ARNameType,
            POINTER(arh.AREntryIdList), POINTER(arh.ARInternalIdList),
            POINTER(arh.ARFieldValueList), POINTER(arh.ARStatusList)
        ]
        self.arlib.ARGetEntry.restype = c_int

        # ARGetListEntryWithFields
        self.arlib.ARGetListEntryWithFields.argtypes = [
            POINTER(arh.ARControlStruct), arh.ARNameType,
            POINTER(arh.ARQualifierStruct), POINTER(arh.AREntryListFieldList),
            POINTER(arh.ARSortList), c_uint, c_uint, arh.ARBoolean,
            POINTER(arh.AREntryListFieldValueList), POINTER(c_uint),
            POINTER(arh.ARStatusList)
        ]
        self.arlib.ARGetListEntryWithFields.restype = c_int

        # ARGetListField
        self.arlib.ARGetListField.argtypes = [
            POINTER(arh.ARControlStruct), arh.ARNameType, arh.ARULong32,
            arh.ARTimestamp, POINTER(arh.ARPropList),
            POINTER(arh.ARInternalIdList), POINTER(arh.ARStatusList)
        ]
        self.arlib.ARGetListField.restype = c_int

        # ARGetListSchema
        self.arlib.ARGetListSchema.argtypes = [
            POINTER(arh.ARControlStruct), arh.ARTimestamp, c_uint,
            arh.ARNameType, POINTER(arh.ARInternalIdList),
            POINTER(arh.ARPropList), POINTER(arh.ARNameList),
            POINTER(arh.ARStatusList)
        ]
        self.arlib.ARGetListSchema.restype = c_int

        # ARGetMultipleFields
        self.arlib.ARGetMultipleFields.argtypes = [
            POINTER(arh.ARControlStruct), arh.ARNameType,
            POINTER(arh.ARInternalIdList), POINTER(arh.ARBooleanList),
            POINTER(arh.ARInternalIdList), POINTER(arh.ARNameList),
            POINTER(arh.ARFieldMappingList), POINTER(arh.ARUnsignedIntList),
            POINTER(arh.ARUnsignedIntList), POINTER(arh.ARUnsignedIntList),
            POINTER(arh.ARUnsignedIntList), POINTER(arh.ARValueList),
            POINTER(arh.ARPermissionListList),
            POINTER(arh.ARPermissionListList), POINTER(arh.ARFieldLimitList),
            POINTER(arh.ARDisplayInstanceListList),
            POINTER(arh.ARTextStringList), POINTER(arh.ARTimestampList),
            POINTER(arh.ARAccessNameList), POINTER(arh.ARAccessNameList),
            POINTER(arh.ARTextStringList), POINTER(arh.ARPropListList),
            POINTER(arh.ARStatusList)
        ]
        self.arlib.ARGetMultipleFields.restype = c_int

        # ARInitialization
        self.arlib.ARInitialization.argtypes = [
            POINTER(arh.ARControlStruct), POINTER(arh.ARStatusList)
        ]
        self.arlib.ARInitialization.restype = c_int

        # ARLoadARQualifierStruct
        self.arlib.ARLoadARQualifierStruct.argtypes = [
            POINTER(arh.ARControlStruct), arh.ARNameType, arh.ARNameType,
            c_char_p, POINTER(arh.ARQualifierStruct), POINTER(arh.ARStatusList)
        ]
        self.arlib.ARLoadARQualifierStruct.restype = c_int

        # ARSetEntry
        self.arlib.ARSetEntry.argtypes = [
            POINTER(arh.ARControlStruct), arh.ARNameType,
            POINTER(arh.AREntryIdList), POINTER(arh.ARFieldValueList),
            arh.ARTimestamp, c_uint, POINTER(arh.ARStatusList)
        ]
        self.arlib.ARSetEntry.restype = c_int

        # ARSetServerPort
        self.arlib.ARSetServerPort.argtypes = [
            POINTER(arh.ARControlStruct), arh.ARNameType, c_int, c_int,
            POINTER(arh.ARStatusList)
        ]
        self.arlib.ARSetServerPort.restype = c_int

        # ARTermination
        self.arlib.ARTermination.argtypes = [
            POINTER(arh.ARControlStruct), POINTER(arh.ARStatusList)
        ]
        self.arlib.ARTermination.restype = c_int

        # FreeARBooleanList
        self.arlib.FreeARBooleanList.argtypes = [
            POINTER(arh.ARBooleanList), arh.ARBoolean
        ]
        self.arlib.FreeARBooleanList.restype = None

        # FreeAREntryIdList
        self.arlib.FreeAREntryIdList.argtypes = [
            POINTER(arh.AREntryIdList), arh.ARBoolean
        ]
        self.arlib.FreeAREntryIdList.restype = None

        # FreeAREntryListFieldList
        self.arlib.FreeAREntryListFieldList.argtypes = [
            POINTER(arh.AREntryListFieldList), arh.ARBoolean
        ]
        self.arlib.FreeAREntryListFieldList.restype = None

        # FreeAREntryListFieldValueList
        self.arlib.FreeAREntryListFieldValueList.argtypes = [
            POINTER(arh.AREntryListFieldValueList), arh.ARBoolean
        ]
        self.arlib.FreeAREntryListFieldValueList.restype = None

        # FreeARFieldValueList
        self.arlib.FreeARFieldValueList.argtypes = [
            POINTER(arh.ARFieldValueList), arh.ARBoolean
        ]
        self.arlib.FreeARFieldValueList.restype = None

        # FreeARInternalIdList
        self.arlib.FreeARInternalIdList.argtypes = [
            POINTER(arh.ARInternalIdList), arh.ARBoolean
        ]
        self.arlib.FreeARInternalIdList.restype = None

        # FreeARNameList
        self.arlib.FreeARNameList.argtypes = [
            POINTER(arh.ARNameList), arh.ARBoolean
        ]
        self.arlib.FreeARNameList.restype = None

        # FreeARQualifierStruct
        self.arlib.FreeARQualifierStruct.argtypes = [
            POINTER(arh.ARQualifierStruct), arh.ARBoolean
        ]
        self.arlib.FreeARQualifierStruct.restype = None

        # FreeARStatusList
        self.arlib.FreeARStatusList.argtypes = [
            POINTER(arh.ARStatusList), arh.ARBoolean
        ]
        self.arlib.FreeARStatusList.restype = None

    def _extract_field(self, schema, field_id, value_struct):
        """Returns the appropriate value for the schema and field id requested
        given a particular value structure.

        :param str schema: the schema name related to the field you're extract
                           data for
        :param str field_id: the field id of the schema being retrieved
        :param ARValueStruct value_struct: the Remedy ARValueStruct containing
                                           the data
        :return: the value of the field requested
        :raises: ARSError
        """

        # Determine the data type of the value
        data_type = value_struct.dataType

        # Retrieve the field name from the cache
        field_name = self.field_id_to_name_cache[schema][field_id]

        # Based on the data type, retrieve and convert (if necessary) the
        # appropriate value and return it to the caller
        if data_type == arh.AR_DATA_TYPE_NULL:
            return None
        elif data_type == arh.AR_DATA_TYPE_INTEGER:
            return value_struct.u.intVal
        elif data_type == arh.AR_DATA_TYPE_REAL:
            return value_struct.u.realVal
        elif data_type == arh.AR_DATA_TYPE_CHAR:
            return value_struct.u.charVal
        elif data_type == arh.AR_DATA_TYPE_ENUM:
            return (
                self.enum_id_to_name_cache[schema][field_id][value_struct.u.enumVal]
            )
        elif data_type == arh.AR_DATA_TYPE_TIME:
            return datetime.fromtimestamp(value_struct.u.timeVal)
        else:
            raise ARSError(
                'An unknown data type was encountered for field name '
                '{} on schema {}'.format(field_name, schema)
            )

    def _update_field(self, schema, field_id, value, field_value_struct):
        """Updates a provided ARFieldValueStruct item with the appropriate
        field information based on the type of value provided.

        :param str schema: the schema name related to the field you're updating
        :param str field_id: the field id of the schema being updated
        :param value: the value that is to be placed in the given field id
        :type value: a value corresponding to the type of the respective field
        :param ARFieldValueStruct field_value_struct: a ARFieldValueStruct to
                                                      update with the given
                                                      field id and value
        :raises: ARSError
        """

        # Determine the data type of the value
        data_type = self.field_id_to_type_cache[schema][field_id]

        # Retrieve the field name from the cache
        field_name = self.field_id_to_name_cache[schema][field_id]

        field_value_struct.fieldId = field_id
        field_value_struct.value.dataType = data_type
        if data_type == arh.AR_DATA_TYPE_NULL:
            pass
        elif data_type == arh.AR_DATA_TYPE_INTEGER:
            field_value_struct.value.u.intVal = value
        elif data_type == arh.AR_DATA_TYPE_REAL:
            field_value_struct.value.u.realVal = value
        elif data_type == arh.AR_DATA_TYPE_CHAR:
            # Ensure that we don't pass a NULL pointer into strdup
            if value is None:
                raise ARSError(
                    'The value specified for field name {} on schema {} '
                    'cannot be None'.format(field_name, schema)
                )
            # Note that we must allocate a new block of memory using
            # strdup or we end up with a nasty invalid pointer error
            field_value_struct.value.u.charVal = cast(
                self.clib.strdup(enc_u8(value)), c_char_p
            )
        elif data_type == arh.AR_DATA_TYPE_ENUM:
            try:
                enum_id = self.enum_name_to_id_cache[schema][field_id][value]
            except KeyError:
                raise ARSError(
                    'An invalid value {} was specified for field name {} '
                    'on schema {}'.format(value, field_name, schema)
                )
            field_value_struct.value.u.enumVal = enum_id
        elif data_type == arh.AR_DATA_TYPE_TIME:
            field_value_struct.value.u.timeVal = int(value.strftime('%s'))
        else:
            raise ARSError(
                'An unknown data type was encountered for field name {} '
                'on schema {}'.format(field_name, schema)
            )

    def _update_errors(self, schema=None):
        """Updates the errors attribute with any errors that occurred on the
        last operation based on the status struct.

        :param str schema: the schema name related to the error (only required
                           for create and update operations)
        """

        # Go through each error present and add them to the errors list
        for i in range(self.status.numItems):
            message_number = self.status.statusList[i].messageNum
            message_text = self.status.statusList[i].messageText
            appended_text = None

            if self.status.statusList[i].appendedText:
                # If a schema is specified and we encounter one of the
                # following errors, we must map field ids to names in the
                # appended text field of the error.
                # ARERR 307: Required field (without a default) not specified
                # ARERR 326: Required field cannot be reset to a NULL value
                if schema and message_number in [307, 326]:
                    try:
                        field_id = int(self.status.statusList[i].appendedText)
                        appended_text = (
                            self.field_id_to_name_cache[schema][field_id]
                        )
                    except (ValueError, IndexError):
                        appended_text = self.status.statusList[i].appendedText
                else:
                    appended_text = self.status.statusList[i].appendedText

            self.errors.append((message_number, message_text, appended_text))
